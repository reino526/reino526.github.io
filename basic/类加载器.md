---
sort: 28
---

# 类加载器

每个 Java 程序至少拥有三个类加载器：

- 引导类加载器
- 平台类加载器
- 系统类加载器（ 应用类加载器 ）

引导类加载器加载大量的 JDK 内部模块中的平台类，没有对应的 ClassLoader 对象，例如，方法

```java
StringBuilder.class.getClassLoader()
```

将返回 null

平台类加载器会加载引导类加载器没有加载的 Java 平台中的所有类

系统加载器会从模块路径和类路径加载应用类

```tip
在 Java 9 之前，扩展类加载器会加载 jre/lib/ext 目录中的标准扩展
```

除了引导类加载器外，每个类加载器都有一个父类加载器，只有在父类加载器加载失败时，它才会加载该类

考虑一个场景，需要使用 Class.forName 加载的类对于使用的类加载器说是不可见的，这种现象称为类加载器倒置，解决这个问题可以将类加载器作为一个参数传递给它，或者可以将恰当的类加载器设置为当前线程的上下文类加载器

```note
每个线程都有一个对类加载器的引用，称为上下文类加载器，主线程的上下文类加载器是系统类加载器，新线程创建时，上下文类加载器会被设置成创建该线程的上下文类加载器，因此不做任何操作时都是系统类加载器
```

```java
Thread t = Thread.currentThread();
t.setContextClassLoader(loader);
```

```note
在同一个虚拟机中，可以有两个类，类名和包名都是相同的，类是由它的全名和类加载器来确定的，这项技术在加载来自多出的代码时很有用，如应用服务器为每一个应用使用单独的类加载器，使得虚拟机可以区分来自不同应用的类
```

我们可以编写自己觉得用于特殊目的的类加载器，在向虚拟机传递字节码之前执行定制的检查

如果要编写自己觉得类加载器，需要基础 ClassLoader 类，然后覆盖下面这个方法：

```java
findClass(String className)
```

loadClass 方法用于将类的加载操作委托给其父类进行，父类无法加载时才调用 findClass 方法

实现该方法，必须做到：

1. 为来自本地文件系统或者其他来源的类获取其字节码
2. 调用超类 ClassLoader 的 defineClass 方法，向虚拟机提供字节码

当类加载器将新加载的 Java 平台类的字节码传递给虚拟机时，字节码首先要接受校验器（ verifier ）的校验，检查那些指令无法执行的明显有破坏性的操作，除了系统类外，所有的类都要被校验

校验器执行的一些检查：

- 变量要在使用之前进行初始化
- 方法调用与对象引用类型之间要匹配
- 访问私有数据和方法的规则没有被违反
- 对本地变量的访问都落在运行时堆栈内
- 运行时堆栈没有溢出

可以使用 `-noverify` 选项（ 或者 `-Xverify:none` ）来关闭检验：

```shell
java -noverify verifier.VerifierTest
```



